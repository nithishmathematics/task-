name: service-ci-cd
on:
  push:
    paths:
      - 'k8s/helm/**'
      - 'services/**'
      - '.github/workflows/service-ci-cd.yml'
jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Build and push image (example)
        uses: docker/build-push-action@v6
        with:
          context: ./services/user-service
          push: true
          tags: ghcr.io/${{ github.repository_owner }}/user-service:${{ github.sha }}
  deploy-dev:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
      # AWS EKS context
      - name: Configure AWS credentials (if provided)
        if: ${{ secrets.AWS_ACCESS_KEY_ID != '' && secrets.AWS_SECRET_ACCESS_KEY != '' }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION || 'us-east-1' }}
      - name: Set EKS context (if AWS credentials provided)
        if: ${{ secrets.AWS_ACCESS_KEY_ID != '' && secrets.AWS_SECRET_ACCESS_KEY != '' }}
        run: |
          EKS_CLUSTER_NAME=${{ secrets.EKS_CLUSTER_NAME || 'task-dev-eks' }}
          aws eks update-kubeconfig --name "$EKS_CLUSTER_NAME" --region "${{ secrets.AWS_REGION || 'us-east-1' }}"
      # Azure AKS context
      - name: Azure login (if provided)
        if: ${{ secrets.AZURE_CREDENTIALS != '' }}
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      - name: Set AKS context (if Azure provided)
        if: ${{ secrets.AZURE_CREDENTIALS != '' && secrets.AKS_RESOURCE_GROUP != '' && secrets.AKS_CLUSTER_NAME != '' }}
        uses: azure/aks-set-context@v3
        with:
          resource-group: ${{ secrets.AKS_RESOURCE_GROUP }}
          cluster-name: ${{ secrets.AKS_CLUSTER_NAME }}
      # Generic kubeconfig
      - name: Load kubeconfig from secret (if provided)
        if: ${{ secrets.AZURE_CREDENTIALS == '' && secrets.AWS_ACCESS_KEY_ID == '' && secrets.KUBECONFIG_B64 != '' }}
        run: |
          echo "${KUBECONFIG_B64}" | base64 -d > kubeconfig
          echo "KUBECONFIG=$PWD/kubeconfig" >> $GITHUB_ENV
        env:
          KUBECONFIG_B64: ${{ secrets.KUBECONFIG_B64 }}
      - name: Ensure ingress-nginx
        run: |
          set -e
          if ! kubectl get ns ingress-nginx >/dev/null 2>&1; then
            helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
            helm repo update
            helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
              --namespace ingress-nginx --create-namespace
          fi
      - name: Wait for ingress external IP/hostname
        run: |
          set -e
          for i in {1..30}; do
            HOSTNAME=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || true)
            IP=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || true)
            if [ -n "$IP" ]; then echo "Found ingress IP: $IP"; break; fi
            if [ -n "$HOSTNAME" ]; then echo "Found ingress hostname: $HOSTNAME"; break; fi
            echo "Waiting for ingress LoadBalancer... ($i)"; sleep 10;
          done
          echo "LB_HOSTNAME=$HOSTNAME" >> $GITHUB_ENV
          echo "LB_IP=$IP" >> $GITHUB_ENV
      - name: Resolve IP from hostname (if needed)
        run: |
          set -e
          if [ -z "$LB_IP" ] && [ -n "$LB_HOSTNAME" ]; then
            sudo apt-get update && sudo apt-get install -y dnsutils >/dev/null
            RESOLVED_IP=$(nslookup "$LB_HOSTNAME" | awk '/Address: /{print $2; exit}')
            echo "Resolved $LB_HOSTNAME to $RESOLVED_IP"
            echo "LB_IP=$RESOLVED_IP" >> $GITHUB_ENV
          fi
      - name: Compute nip.io host
        run: |
          set -e
          if [ -z "$LB_IP" ]; then
            echo "Ingress IP not available; cannot compute nip.io hostname" >&2
            exit 1
          fi
          INGRESS_HOST="user.${LB_IP}.nip.io"
          echo "INGRESS_HOST=$INGRESS_HOST" >> $GITHUB_ENV
          echo "Service URL will be: http://$INGRESS_HOST/healthz"
      - name: Fetch RDS creds and create K8s Secret
        if: ${{ secrets.AWS_ACCESS_KEY_ID != '' && secrets.AWS_SECRET_ACCESS_KEY != '' }}
        run: |
          set -e
          sudo apt-get update && sudo apt-get install -y jq >/dev/null
          DB_IDENTIFIER="${DB_INSTANCE_IDENTIFIER:-task-dev-pg}"
          DB_JSON=$(aws rds describe-db-instances --db-instance-identifier "$DB_IDENTIFIER")
          DB_ENDPOINT=$(echo "$DB_JSON" | jq -r '.DBInstances[0].Endpoint.Address')
          DB_NAME=$(echo "$DB_JSON" | jq -r '.DBInstances[0].DBName // "userdb"')
          DB_USER=$(echo "$DB_JSON" | jq -r '.DBInstances[0].MasterUsername')
          SECRET_ARN=$(echo "$DB_JSON" | jq -r '.DBInstances[0].MasterUserSecret.SecretArn')
          if [ -z "$SECRET_ARN" ]; then echo "No MasterUserSecret ARN found on DB instance" >&2; exit 1; fi
          SECRET_JSON=$(aws secretsmanager get-secret-value --secret-id "$SECRET_ARN" | jq -r '.SecretString')
          DB_PASS=$(echo "$SECRET_JSON" | jq -r '.password // .Password // .PASS // empty')
          if [ -z "$DB_PASS" ]; then echo "Password not found in secret string" >&2; exit 1; fi
          DATABASE_URL="postgres://${DB_USER}:${DB_PASS}@${DB_ENDPOINT}:5432/${DB_NAME}"
          # Create or update the secret
          kubectl create secret generic user-service-db --from-literal=url="$DATABASE_URL" -o yaml --dry-run=client | kubectl apply -f -
      - name: Helm install/upgrade user-service
        run: |
          helm upgrade --install user-service k8s/helm/user-service \
            --set image.repository=ghcr.io/${{ github.repository_owner }}/user-service \
            --set image.tag=${{ github.sha }} \
            --set ingress.enabled=true \
            --set ingress.className=nginx \
            --set ingress.hosts[0].host=${INGRESS_HOST} \
            --set database.enabled=true \
            --set database.existingSecret="user-service-db"
      - name: Output service URL
        run: |
          echo "# Deployment" >> $GITHUB_STEP_SUMMARY
          echo "User service: http://${INGRESS_HOST}/" >> $GITHUB_STEP_SUMMARY
          echo "Healthcheck: http://${INGRESS_HOST}/healthz" >> $GITHUB_STEP_SUMMARY
          echo "DB Health: http://${INGRESS_HOST}/db-health" >> $GITHUB_STEP_SUMMARY
